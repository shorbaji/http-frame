;; TODO
;;
;; Section 3.2   starting HTTP/2 with https
;; logging
;; purhcase certificate
;; LAUNCH web site
;; Solve the enforce-tls-profile problem
;; Section 3.1   starting HTTP/2 with HTTP/1.1 Upgrade
;; implement stream-level priority
;; stream clean-up
;; revisit stream errors
;; - decoding/encoding errors => connection error compression error
;;   optional - sender of settings frame does not receive an ack wihtin a reasonable amount of time
;;   connection error settings timeout
;; if connection error don't do window update
;; if stream error do window update
;; - implement change to SETTINGS_INITIAL_WINDOW_SIZE issuing a connection control error if that causes
;;   any flow control window to exceed the maximum size
;; detect and handle thread closure  
;;
;; Section 5.3   stream priority
;; Section 8.3   the CONNECT method
;; Section 10    security
;; Section 5.1.1 stream identifiers
;; Section 5.1.2 implement SETTINGS-MAX-CONCURRENT-STREAMS - section 5.1.2
;; Section 8.1.4 request reliability
;; Section 9     additional considerations
;; The rest of HTTP

(define (spew . args)
  (for-each (lambda (x) (display x (current-error-port))) args)
  (newline (current-error-port)))

;;;
;;; hpack
;;;

(module hpack
    (make-header-table set-header-table! update-header-table hpack-encode hpack-decode)
  (import chicken scheme)
  (use srfi-1 defstruct data-structures)

  ;; The Huffman code - copied directly from Appendix C and used to encode 

  (define huffman-code
    '(
      (1 1 1 1 1 1 1 1 1 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1)
      (0 1 0 1 0 0)
      (1 1 1 1 1 1 1 0 0 0)
      (1 1 1 1 1 1 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 0 0 1)
      (0 1 0 1 0 1)
      (1 1 1 1 1 0 0 0)
      (1 1 1 1 1 1 1 1 0 1 0)
      (1 1 1 1 1 1 1 0 1 0)
      (1 1 1 1 1 1 1 0 1 1)
      (1 1 1 1 1 0 0 1)
      (1 1 1 1 1 1 1 1 0 1 1)
      (1 1 1 1 1 0 1 0)
      (0 1 0 1 1 0)
      (0 1 0 1 1 1)
      (0 1 1 0 0 0)
      (0 0 0 0 0)
      (0 0 0 0 1)
      (0 0 0 1 0)
      (0 1 1 0 0 1)
      (0 1 1 0 1 0)
      (0 1 1 0 1 1)
      (0 1 1 1 0 0)
      (0 1 1 1 0 1)
      (0 1 1 1 1 0)
      (0 1 1 1 1 1)
      (1 0 1 1 1 0 0)
      (1 1 1 1 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 0 0)
      (1 0 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 0 1 1)
      (1 1 1 1 1 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 0 1 0)
      (1 0 0 0 0 1)
      (1 0 1 1 1 0 1)
      (1 0 1 1 1 1 0)
      (1 0 1 1 1 1 1)
      (1 1 0 0 0 0 0)
      (1 1 0 0 0 0 1)
      (1 1 0 0 0 1 0)
      (1 1 0 0 0 1 1)
      (1 1 0 0 1 0 0)
      (1 1 0 0 1 0 1)
      (1 1 0 0 1 1 0)
      (1 1 0 0 1 1 1)
      (1 1 0 1 0 0 0)
      (1 1 0 1 0 0 1)
      (1 1 0 1 0 1 0)
      (1 1 0 1 0 1 1)
      (1 1 0 1 1 0 0)
      (1 1 0 1 1 0 1)
      (1 1 0 1 1 1 0)
      (1 1 0 1 1 1 1)
      (1 1 1 0 0 0 0)
      (1 1 1 0 0 0 1)
      (1 1 1 0 0 1 0)
      (1 1 1 1 1 1 0 0)
      (1 1 1 0 0 1 1)
      (1 1 1 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 0 0)
      (1 0 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 0 1)
      (0 0 0 1 1)
      (1 0 0 0 1 1)
      (0 0 1 0 0)
      (1 0 0 1 0 0)
      (0 0 1 0 1)
      (1 0 0 1 0 1)
      (1 0 0 1 1 0)
      (1 0 0 1 1 1)
      (0 0 1 1 0)
      (1 1 1 0 1 0 0)
      (1 1 1 0 1 0 1)
      (1 0 1 0 0 0)
      (1 0 1 0 0 1)
      (1 0 1 0 1 0)
      (0 0 1 1 1)
      (1 0 1 0 1 1)
      (1 1 1 0 1 1 0)
      (1 0 1 1 0 0)
      (0 1 0 0 0)
      (0 1 0 0 1)
      (1 0 1 1 0 1)
      (1 1 1 0 1 1 1)
      (1 1 1 1 0 0 0)
      (1 1 1 1 0 0 1)
      (1 1 1 1 0 1 0)
      (1 1 1 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 0 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 0)
      (1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1)))  

					; Naive implementation of Huffman decoding 
					; We convert the input to a bit stream
					; We traverse a tree going left if 0, right is 1 and return the leaf

  (define huffman-tree
    '(((((48 . 49) 50 . 97) (99 . 101) 105 . 111)
       ((115 . 116) (32 . 37) 45 . 46) ((47 . 51) 52 . 53)
       (54 . 55) 56 . 57) ((((61 . 65) 95 . 98) (100 . 102) 103 . 104)
       ((108 . 109) 110 . 112) (114 . 117) (58 . 66) 67 . 68)
       ((((69 . 70) 71 . 72) (73 . 74) 75 . 76) ((77 . 78) 79 . 80) (81 . 82) 83 . 84)
       (((85 . 86) 87 . 89) (106 . 107) 113 . 118) ((119 . 120) 121 . 122)
       ((38 . 42) 44 . 59) (88 . 90) ((33 . 34) 40 . 41) (63 39 . 43)
       (124 35 . 62) ((0 . 36) 64 . 91) (93 . 126) (94 . 125) (60 . 96) 123
       (((92 . 195) 208 128 . 130) ((131 . 162) 184 . 194) (224 . 226) (153 . 161) 167 . 172)
       ((((176 . 177) 179 . 209) (216 . 217) 227 . 229)
	((230 129 . 132) (133 . 134) 136 . 146) ((154 . 156) 160 . 163) (164 . 169) 170 . 173)
       ((((178 . 181) 185 . 186) (187 . 189) 190 . 196)
	((198 . 228) 232 . 233) ((1 . 135) 137 . 138) (139 . 140) 141 . 143)
       ((((147 . 149) 150 . 151) (152 . 155) 157 . 158)
	((165 . 166) 168 . 174) (175 . 180) 182 . 183)
       (((188 . 191) 197 . 231) (239 9 . 142) (144 . 145) 148 . 159)
       (((171 . 206) 215 . 225) (236 . 237) (199 . 207) 234 . 235)
       ((((192 . 193) 200 . 201) (202 . 205) 210 . 213)
	((218 . 219) 238 . 240) (242 . 243) 255 203 . 204)
       ((((211 . 212) 214 . 221) (222 . 223) 241 . 244)
	((245 . 246) 247 . 248) (250 . 251) 252 . 253)
       (((254 2 . 3) (4 . 5) 6 . 7) ((8 . 11) 12 . 14) (15 . 16) 17 . 18)
       (((19 . 20) 21 . 23) (24 . 25) 26 . 27) ((28 . 29) 30 . 31)
       (127 . 220) 249 (10 . 13) 22 . 256))


  (define (an-atom? x)
    (and (not (pair? x))
         (not (null? x))))

  (define (huffman-find t s p)
    (if (an-atom? s)
	(cons s (huffman-find t t p))
	(if (null? p)
	    '()
	    (if (zero? (car p))
		(huffman-find t (car s) (cdr p))
		(huffman-find t (cdr s) (cdr p))))))

  (define (bytes->bits ls)		; ugly
    (define (byte->bits b #!optional (n 8))
      (let lp ((i n) (x b) (r '()))
	(if (zero? i)
	    r
	    (lp (sub1 i)
		(quotient x 2)
		(cons (modulo x 2)
		      r)))))
    (reverse (append-map byte->bits (reverse ls))))

  (define (huffman-decode bytes)
    (huffman-find huffman-tree
                  huffman-tree
                  (bytes->bits bytes)))

					; Naive implementation of Huffman encoding

  (define (bits->bytes bits)
    (if (null? bits)
	'()
	(cons (fold (lambda (x s) (+ (* s 2) x)) 0 (take bits 8))
	      (bits->bytes (drop bits 8)))))

  (define (huffman-encode bytes)
    (let* ((bits (append-map (lambda (b) (list-ref huffman-code b)) bytes))
           (r (remainder (length bits) 8))
           (eos (list-ref huffman-code 256))
           (pad (if (zero? r) '() (take eos (- 8 r))))
           (bits (append bits pad)))
      (bits->bytes bits)))

  ;; Section 3.3.1 Static Table (entries defined in Appendix B)

  (define static-table
    '((:authority)
      (:method . "GET")
      (:method . "POST")
      (:path . "/")
      (:path . "/index.html")
      (:scheme . "http")
      (:scheme . "https")
      (:status . "200")
      (:status . "204")
      (:status . "206")
      (:status . "304")
      (:status . "400")
      (:status . "404")
      (:status . "500")
      (accept-charset . "")
      (accept-encoding . "gzip, deflate")
      (accept-language . "")
      (accept-ranges . "")
      (accept . "")
      (access-control-allow-origin . "")
      (age . "")
      (allow . "")
      (authorization . "")
      (cache-control . "")
      (content-disposition . "")
      (content-encoding . "")
      (content-language . "")
      (content-length . "")
      (content-location . "")
      (content-range . "")
      (content-type . "")
      (cookie . "")
      (date . "")
      (etag . "")
      (expect . "")
      (expires . "")
      (from . "")
      (host . "")
      (if-match . "")
      (if-modified-since . "")
      (if-none-match . "")
      (if-range . "")
      (if-unmodified-since . "")
      (last-modified . "")
      (link . "")
      (location . "")
      (max-forwards . "")
      (proxy-authenticate . "")
      (proxy-authorization . "")
      (range . "")
      (referer . "")
      (refresh . "")
      (retry-after . "")
      (server . "")
      (set-cookie . "")
      (strict-transport-security . "")
      (transfer-encoding . "")
      (user-agent . "")
      (vary . "")
      (via . "")
      (www-authenticate . "")))

  (define static-table-length 61)

  ;; Section 3.3.2 Header Table

  (define DEFAULT-HEADER-TABLE-SIZE 4096)
  
  (defstruct header-table
    (headers '())
    (usage 0)
    (size DEFAULT-HEADER-TABLE-SIZE))

  ;; Section 3.3.3 Index Address Space
  ;; Note: static-table and header-table indexes start at 1

  (define (index-table-lookup index ht)
    (let ((headers (header-table-headers ht)))
      (if (> index (+ static-table-length (length headers)))
	  (signal 'hpack-error)
	  (if (<= index static-table-length)
	      (list-ref static-table (- index 1))
	      (list-ref headers (- index static-table-length 1))))))

					; Section 5 - Header Table Management

  (define (header-size h)
    (let ((name (car h))
          (value (cdr h)))
      (+ (string-length (symbol->string name))
         (string-length value))))

  (define (header-table-prune ht)
    (let ((usage (header-table-usage ht))
          (size (header-table-size ht))
          (headers (header-table-headers ht)))
      (if (or (zero? usage)
              (null? headers)
              (<= usage size))
	  ht
	  (header-table-prune
	   (update-header-table ht
				headers: (drop-right headers 1)
				usage: (- usage (header-size (last headers))))))))

  (define (header-table-change-size ht new-size)
    (header-table-prune
     (update-header-table ht size: new-size)))

  (define (header-table-insert ht entry)
    (let* ((headers (header-table-headers ht))
           (usage (header-table-usage ht))
           (size (header-table-size ht))
           (entry-size (header-size entry))
           (new-headers (cons entry headers)))
      (header-table-prune
       (update-header-table ht
			    headers: new-headers
			    usage: (+ entry-size usage)))))
  (define (header-eq? h)
    (lambda (x) (and (eq? (car x) (car h))
                     (not (null? (cdr x)))
                     (string=? (cdr x) (cdr h)))))

  (define (name-eq? h)
    (lambda (x) (and (eq? (car x) (car h)))))

  (define (header-table-finder pred)
    (lambda (ht h)
      (let* ((hdrs (header-table-headers ht))
             (pred (pred h))
             (in-static? (list-index pred static-table)))
        (or (and in-static?
                 (+ in-static? 1))
            (let ((in-header-table?  (list-index pred hdrs)))
              (and in-header-table?
                   (+ in-header-table? 1 static-table-length)))))))

  (define header-table-find (header-table-finder header-eq?))
  (define header-table-find-name (header-table-finder name-eq?))

					; HPACK decoder and encoder.
					; Usage note: An encoder and decoder each maintain a seperate header table as context.
					; Each HTTP/2 connection should have exactly one encoder and one decoder associated with it.

					; The decoder is implemented as a simple recursive decent parser

					; Section 6.1 Integer Representation
					; instead of prefix we use 2^prefix as argument mask
					; so prefix 7 is "mask 128"

  (define (rest-of-integer r m ls)
    (or (and (null? ls)
             (signal 'hpack-error))
        (let ((o (car ls)))
          (if (< o 128)
	      (values (+ r (* m o)) (cdr ls))
	      (rest-of-integer (+ r (* m (- o 128)))
			       (* m 128)
			       (cdr ls))))))

  (define (integer mask ls)
    (or (and (null? ls)
             (signal 'hpack-error))
        (let ((n (modulo (car ls) mask)))
          (if (eq? (+ n 1) mask)
	      (rest-of-integer n 1 (cdr ls))
	      (values n (cdr ls))))))

					; Section 6.2 String Representation

  (define (string-value n ls)
    (if (< (length ls)
	    n)
	(signal 'hpack-error)
        (values (take ls n) (drop ls n))))
  

  (define (string-literal ls)
    (or (and (null? ls)
             (signal 'hpack-error))
        (let* ((tmp ls)
               (o (car ls))
               (huff (>= o 128)))
          (receive (n ls) (integer 128 ls)
            (receive (s ls) (string-value n ls)
              (values (list->string
		       (map integer->char
			    (if huff (huffman-decode s) s)))
                      ls))))))

					; Section 7.1 Index Header Field Representation
					; Simply get an integer with 7-prefix and lookup in index table

  (define (index-header ht ls)
    (receive (n ls)
	(integer 128 ls)
      (values (index-table-lookup n ht)
              ht
              ls)))

					; Section 7.2 Literal Header Field Representation

  (define (indexed-name ht ls)
    (let* ((o (car ls))
           (m (cond ((> o 64) 64)
                    (else 16))))
      (receive (n ls)
	  (integer m ls)
        (let ((name (car (index-table-lookup n ht))))
          (values name ls)))))

  (define (new-name ht ls)
    (receive (s ls)
	(string-literal ls)
      (values (string->symbol s) ls)))

  (define (literal-header-name ht ls)
    (let ((new-name? (member (car ls) '(64 16 0))))
      (if new-name?
	  (new-name ht (cdr ls))
	  (indexed-name ht ls))))

  (define literal-header-value
    string-literal)

  (define (literal-header ht ls)
    (let ((index? (>= (car ls) 64)))
      (receive (name ls)
	  (literal-header-name ht ls)
        (receive (value ls)
	    (literal-header-value ls)
          (let* ((h (cons name value))
                 (ht (if index?
			 (header-table-insert ht h)
			 ht)))
            (values h ht ls))))))

  (define (header ht ls)
    (let ((indexed? (> (car ls) 128)))
      (if indexed?
	  (index-header ht ls)
	  (literal-header ht ls))))

  (define (update-header-table-size ht ls)
    (receive (n ls)
	(integer 32 ls)
      (values (header-table-change-size ht n) ls)))

  (define (header-list headers ht ls)
    (if (null? ls)
	(values headers ht ls)
	(let ((update? (and (< (car ls) 64) (>= (car ls) 32))))
	  (if update?
	      (receive (ht ls)		; update header table size
		  (update-header-table-size ht ls)
		(header-list headers ht ls))
	      (receive (h ht ls)	; get a header
		  (header ht ls)
		(header-list (cons h headers) ht ls))))))

  (define (hpack-decode header-table code)
    (let ((block (map char->integer (string->list code))))
      (receive (headers ht ls)
	  (header-list '() header-table block)
	(set-header-table! header-table
			   headers: (header-table-headers ht)
			   size: (header-table-size ht)
			   usage: (header-table-usage ht))
	(reverse headers))))


  ;; Encoder

  (define (rest-of-integer->code n)
    (if (< n 128)
	(list n)
	(cons (+ 128 (modulo n 128)) (rest-of-integer->code (quotient n 128)))))

  (define (integer->code base mask n)
    (if (> n mask)
	(cons (+ base mask)
	      (rest-of-integer->code (- n mask)))
	(list (+ base n))))

  (define (string->code s)
    (let* ((bytes (map char->integer (string->list s)))
           (h (huffman-encode bytes))
           (huffman? (< (length h) (length bytes)))
           (len (min (length h) (length bytes)))
           (to-send (if huffman?  h bytes))
           (m (if huffman? 128 0)))
      (append
       (integer->code m 127 len)
       to-send)))

  (define (header->code h index name-index index-header?)
    (if index
	(integer->code 128 127 index)
	(if name-index
	    (append (if index-header?
			(integer->code 64 63 name-index)
			(integer->code 16 15 name-index))
		    (string->code (cdr h)))
	    (append (list (if index-header? 64 16))
		    (string->code (symbol->string (car h)))
		    (string->code (cdr h))))))

  (define (hpack-encode header-table headers #!optional (index-header? #t))
    (if (null? headers)
	'()
	(let* ((h (car headers))
	       (index (header-table-find header-table h))
	       (name-index (header-table-find-name header-table h))
	       (code (header->code h index name-index index-header?)))
	  (if (and index-header? (not index))
	      (let ((ht (header-table-insert header-table h)))
		(set-header-table! header-table
				   headers: (header-table-headers ht)
				   size: (header-table-size ht)
				   usage: (header-table-usage ht))))
	  (conc (list->string (map integer->char code))
		(hpack-encode header-table (cdr headers) index-header?))))))
;;;
;;; frames
;;;
(module http-frame
    (read-frame write-frame frame-types spew)
  (import chicken scheme)
  (use srfi-1 srfi-13 extras data-structures ports )

  (define (spew . args)
    (for-each (lambda (x) (display x (current-error-port))) args)
    (newline (current-error-port)))

					;;octets
  (define (octets->integer octets)
    (fold (lambda (x r) (+ x (* r 256))) 0 octets))

  (define (integer->octets int len)
    (do ((i int (quotient i 256))
         (n len (- n 1))
         (ls '() (cons (modulo i 256) ls)))
	((zero? n) ls)))

  (define (octify s)
    (map char->integer (string->list s)))

  (define (unoctify ls)
    (list->string (map integer->char ls)))

  (define (integer->str i n)
    (unoctify (integer->octets i n)))

  (define (str->integer s)
    (octets->integer (octify s)))

					; settings
  (define known-settings
    '(SETTINGS-HEADER-TABLE-SIZE SETTINGS-ENABLE-PUSH SETTINGS-MAX-CONCURRENT-STREAMS
                                 SETTINGS-INITIAL-WINDOW-SIZE SETTINGS-MAX-FRAME-SIZE SETTINGS-MAX-HEADER-LIST-SIZE))

  (define (str->setting s)
    (let* ((id (str->integer (string-take s 2)))
           (id (or (alist-ref id (zip (cdr (iota 7)) known-settings)) id))
           (val (str->integer (string-drop s 2))))
      (cons id val)))

  (define (str->settings p)
    (let lp ((ls '()) (s p))
      (if (string-null? s)
          (reverse ls)
          (lp (cons (str->setting (string-take s 6)) ls)
              (string-drop s 6)))))

  (define (setting->str s)
    (let* ((id (car s))
           (id (or (alist-ref id (map cons known-settings (cdr (iota 7))))
                   id))
           (val (cdr s)))
      (conc (integer->str id 2)
            (integer->str val 4))))

  (define (settings->str ls)
    (apply conc (map setting->str ls)))

					; flags
  (define (is flag flags) (if (member flag flags) #t #f))
  (define (flag->integer f)
    (alist-ref f `((ack . 1)
                   (end-stream . 1)
                   (end-headers . 4)
                   (padded . 8)
                   (priority . 32))))
  (define (flags->octet fls) (apply + (map flag->integer fls)))

  (define (octet->flags t o)
    (filter-map
     (lambda (triple)
       (and (member t (car triple)) (eq? (bitwise-and o (cadr triple)) (cadr triple)) (caddr triple)))
     '(((settings ping) 1 ack)
       ((data headers) 1 end-stream)
       ((headers push-promise) 4 end-headers)
       ((data headers push-promise) 8 padded)
       ((headers) 32 priority))))

					; frame - utilities
  (define (fuse a b)
    (unoctify (let* ((four (integer->octets b 4)))
                (if (zero? a)
                    four
                    (cons (bitwise-ior (car four) 128) (cdr four))))))

  (define (unfuse s)
    (let* ((ls (octify s)))
      (cons (if (zero? (bitwise-and 128 (car ls))) 0 1)
            (cons (bitwise-and 127 (car ls)) (cdr ls)))))

  (define (str->esdw s)
    (let* ((esd (unfuse (string-take s 4)))
           (e (car esd))
           (sd (cdr esd))
           (w (str->integer (string-drop s 4))))
      (list e sd w)))

  (define (esdw->str e sd w)
    (conc (fuse e sd) (integer->str w 1)))

  (define (pad s pl)
    (if pl (conc (integer->str pl 1) s (string-pad "" pl)) s))

  (define (unpad s flags)
    (let* ((padded (is 'padded flags))
           (pad-length (and padded (char->integer (car (string->list (string-take s 1))))))
           (padding (and padded (string-take-right s pad-length))))
      (if pad-length
          (if (or (< (string-length s) pad-length)
                  (not (string=? padding (string-pad "" pad-length #\0))))
              (error 'protocol-error "non-zero-pad-length")
              (string-drop (string-drop-right s pad-length) 1))
          s)))

					; frame payload parsers
  (define (parse-data-payload l f id p)
    (list id (unpad p f) (is 'end-stream f)))

  (define (parse-headers-payload l f id p)
    (let* ((s (unpad p f))
           (priority? (is 'priority f))
           (esdw (and priority? (str->esdw (string-take s 5))))
           (hbf (if priority? (string-drop s 5) s))
           (eh (is 'end-headers f))
           (es (is 'end-stream f)))
      (list id hbf eh es esdw)))

  (define (parse-priority-payload l f id p)
    (cons id (str->esdw p)))

  (define (parse-rst-stream-payload l f id p)
    (list id (str->integer p)))

  (define (parse-settings-payload l f id p)
    (let* ((s (str->settings p))
           (ack (is 'ack f)))
      (list s ack)))

  (define (parse-push-promise-payload l f id p)
    (let* ((s (unpad p f))
           (psid (str->integer (string-take s 4)))
           (hbf (string-drop s 4))
           (eh (is 'end-headers f)))
      (list id psid hbf eh)))

  (define (parse-ping-payload l f id p)
    (list p))

  (define (parse-goaway-payload l f id p)
    (let* ((ls (str->integer (string-take p 4)))
           (ec (str->integer (string-take (string-drop p 4) 4)))
           (dd (string-drop p 8)))
      (list ls ec dd)))

  (define (parse-window-update-payload l f id p)
    (list id (str->integer p)))

  (define (parse-continuation-payload l f id p)
    (list id p (is 'end-headers f)))

  (define frame-types 
    '(data headers priority rst-stream settings push-promise ping goaway window-update continuation))

  (define parsers
    (map cons frame-types
         (list parse-data-payload parse-headers-payload parse-priority-payload parse-rst-stream-payload
               parse-settings-payload parse-push-promise-payload parse-ping-payload parse-goaway-payload
               parse-window-update-payload parse-continuation-payload)))

  (define (read-length) (read-string 3))
  (define (read-type) (read-string 1))
  (define (read-sid) (read-string 4))
  (define (read-flags) (read-string 1))
  (define read-payload read-string)

  (define parse-sid str->integer)
  (define parse-length str->integer)

  (define (parse-flags s t)
    (octet->flags t (str->integer s)))

  (define (parse-type s)
    (if (string=? "" s)
        'eof
        (alist-ref (str->integer s) (map cons (iota 10) frame-types))))

  (define (parse-payload l t f id s)
    ((alist-ref t parsers) l f id s))

  (define (read-frame)
    (let* ((l (parse-length (read-length)))
           (t (parse-type (read-type)))
           (f (parse-flags (read-flags) t))
           (i (parse-sid (read-sid))))
					; check frame size and handle frame-size errors
      (if (or (and (member t '(rst-stream window-update)) (not (eq? l 4)))
	      (and (eq? t 'ping) (not (eq? l 8)))
	      (and (eq? t 'settings) (not (zero? (modulo l 6))))
	      (and (eq? t 'priority) (not (eq? l 5))))
	  '(connection-error frame-size-error "bad frame size - conn")
	  (let* ((p (parse-payload l t f i (read-payload l))))
	    (cons t p)))))
					;writes
  (define (write-length l)
    (display (integer->str l 3)))

  (define (write-type t)
    (display (integer->char (alist-ref t (map cons frame-types (iota 10))))))

  (define (write-flags f)
    (display (integer->char (flags->octet f))))

  (define (write-sid sid)
    (display (integer->str sid 4)))

  (define (write-all l t f s p)
    (write-length l)
    (write-type t)
    (write-flags f)
    (write-sid s)
    (display p)) 

					; frame unparsers
  (define (write-data-frame sid d es #!optional (pl #f))
    (let* ((l (+ (string-length d) (+ 1 (or pl -1))))
           (f (if es '(end-stream) '()))
           (f (if pl (cons 'padded f) f)))
      (write-all l 'data f sid (pad d pl))))

  (define (write-headers-frame sid hbf eh es #!optional (priority #f) (pl #f))
    (let* ((l (+ (string-length hbf)
                 (if priority 5 0)
                 (+ 1 (or pl -1))))
           (f (filter-map (lambda (p f) (and p f))
                          (list es eh priority pl)
                          '(end-stream end-headers priority padded))))
      (write-all l 'headers f sid (conc (pad hbf pl)
                                        (if priority
                                            (apply esdw->str priority)
                                            "")))))
  (define (write-priority-frame sid e sd w)
    (write-all 5 'priority '() sid (esdw->str e sd w)))

  (define (write-rst-stream-frame sid ec)
    (write-all 4 'rst-stream '() sid (integer->str ec 4)))

  (define (write-settings-frame settings ack)
    (let* ((l (* 6 (length settings))))
      (write-all l 'settings (if ack '(ack) '()) 0 (settings->str settings))))

  (define (write-push-promise-frame sid psid hbf eh #!optional (pl #f))
    (let* ((l (+ (string-length hbf)
                 4
                 (+ 1 (if pl pl -1))))
           (f (filter-map (lambda (p f) (and p f))
                          (list eh pl)
                          '(end-headers padded)))
           (p (conc (integer->str psid 4) hbf)))
      (write-all l 'push-promise f sid p)))

  (define (write-ping-frame data) (write-all 8 'ping '() 0 data))

  (define (write-goaway-frame ls ec dd)
    (write-all (+ 4 (string-length dd)) 'goaway '()
	       0 (conc (integer->str ls 4) (integer->str ec 4) dd)))

  (define (write-window-update-frame sid wsi)
    (write-all 4 'window-update '() sid (integer->str wsi 4)))

  (define (write-continuation-frame sid hbf eh)
    (write-all (string-length hbf) 'continuation (if eh '(end-headers) '()) sid hbf))

  (define writers
    (map cons frame-types
	 (list write-data-frame write-headers-frame write-priority-frame write-rst-stream-frame
	       write-settings-frame write-push-promise-frame write-ping-frame write-goaway-frame
	       write-window-update-frame write-continuation-frame)))  

  (define (write-frame e)
    (let* ((t (car e))
           (fn (alist-ref t writers)))
      
      (if fn
          (apply fn (cdr e))
          (error (cons 'bad-fn-type e))))))

;;; 
;;; streams
;;;
(module http-stream
    (make-stream stream-recv stream-send stream-accepts?)

  (import chicken scheme)
  (use srfi-1 defstruct data-structures)
  (import http-frame)

  (defstruct stream
    (state 'idle)
    (hbls '())
    (db "")
    (local-ws 65535)
    (peer-ws 65535)
    (ec #f))

  (define recv-transition-table
    (map cons
	 '(idle open reserved-local reserved-remote half-closed-remote half-closed-local)
	 '(((push-promise . reserved-remote)  (headers . open))
	   ((end-stream . half-closed-remote)  (rst-stream . closed))
	   ((rst-stream . closed))
	   ((headers . half-closed-local)  (rst-stream . closed))
	   ((rst-stream . closed))
	   ((end-stream . closed)  (rst-stream . closed)))))

  (define send-transition-table
    (map cons
	 '(idle open reserved-local reserved-remote half-closed-remote half-closed-local)
	 '(((push-promise . reserved-local)  (headers . open))
	   ((end-stream . half-closed-local)  (rst-stream . closed))
	   ((headers . half-closed-remote)  (rst-stream . closed))
	   ((rst-stream . closed))
	   ((end-stream . closed)  (rst-stream . closed))
	   ((rst-stream . closed)))))
  
  (define (stream-transition state t table)
    (or (alist-ref t (alist-ref state table))
	state))

  (define (stream-accepts? s t)
    (let* ((state (stream-state s)))
      (member t (case state
		  ((idle)            '(headers push-promise priority))
		  ((reserved-local)  '(priority rst-stream window-update))
		  ((reserved-remote) '(headers rst-stream priority))
		  (else (list t))))))
  
;;; stream-recv
  ;; 
  (define (stream-recv s f handler)
    (let* ((state (stream-state s))
	   (hbls (stream-hbls s))
	   (db (stream-db s))
	   (local-ws (stream-local-ws s))
	   (peer-ws (stream-peer-ws s))
	   (ec (stream-ec s))
	   (t (car f))
	   (id (cadr f)))

      (spew "strm-recv: " f)
      
      (define (continuation-hbfs)
	(let lp ((b ""))
	  (let* ((f (read-frame))
		 (t (car f))
		 (cid (cadr f)))
	    (if (and (eq? 'continuation t)
		     (eq? cid id))
		(let* ((chbf (caddr f))
		       (ceh (cadddr f)))
		  (if ceh
		      (lp (conc b chbf))
		      (conc b chbf)))))))

      (define (transition tr)
	(set! state (stream-transition state tr recv-transition-table)))
      
      (define (transition-on-es es)
	(if es (transition 'end-stream)))

      (define (stream-error ec)
	(stream-send s `(rst-stream ,id ,ec)))
      
;;;
      (if (or (and (eq? t 'data)
		   (not (member state '(open half-closed-local))))
	      (not (member t (case state
			       ((half-closed-remote) '(window-update priority rst-stream))
			       ((closed) '(priority))
			       (else (list t))))))
	  (stream-error 'stream-closed))
      
      
      (transition t)
      
      (let ((fn (case (car f)
		  ((data)           (lambda (data es)
				      (transition-on-es es)
				      (set! db (conc db data))))
		  ((headers)        (lambda (hbf eh es esdw)
				      (let* ((hb (if eh hbf (conc hbf (continuation-hbfs)))))
					(transition-on-es es)
					(set! hbls (cons hb hbls)))))
		  ((rst-stream)     (lambda (fec)
				      (set! ec fec)))
		  ((priority)       (lambda (e sd w)
				      '()))
		  ((window-update)  (lambda (wsi)
				      (if (zero? wsi) (stream-error 'protocol-error))
				      (set! peer-ws (+ wsi peer-ws))))
		  ((push-promise)   (lambda (-promise psid hbf eh)
				      '())))))
	(apply fn (cddr f)))

      (if (and (member state '(half-closed-remote closed))
	       (or (not ec)
		   (zero? ec)))
	  (handler id hbls db))

      (update-stream s state: state hbls: hbls db: db ec: ec)))

  
;;; stream send

  (define (stream-send s f)
    (spew "strm-send: " f)
    (let* ((t (car f))
	   (state (stream-state s)))

      (define (transition tr)
	(set! state (stream-transition state tr send-transition-table)))
      
      (define (transition-on-es es)
	(if es (transition 'end-stream)))


      (define (data d es)
	(transition-on-es es))

      (define (headers hbf eh es)
	(transition-on-es es))

      (define (rst-stream ls ec dd)
	'())

      (transition t)      
      (apply (alist-ref t
			`((data . ,data)
			  (headers . ,headers)
			  (rst-stream . ,rst-stream)))
	     (cddr f))
      (update-stream s state: state))))

;;;
;;; request
;;; 
(module http-request
    (make-request request-authority request-pseudo-headers request-all-headers request-headers
		  make-request-with-headers-and-body)

  (import chicken scheme)
  (use srfi-1 data-structures defstruct)

  (defstruct request
    method host port path
    (scheme "http")
    (headers '())
    (body ""))

  (define (request-authority req)
    (conc (request-host req)
	  (if (request-port req)
	      (conc ":" (request-port req))
	      "")))
  
  (define (request-pseudo-headers req)
    `((:method . ,(conc (request-method req)))
      (:scheme . ,(request-scheme req))
      (:path . ,(request-path req))
      (:authority . ,(request-authority req))))

  (define (request-all-headers req)
    (append (request-pseudo-headers req)
	    (request-headers req)))

  (define (make-request-with-headers-and-body h b)
    (let* ((m (alist-ref ':method h))
	   (p (alist-ref ':path h))
	   (a (alist-ref ':authority h))
	   (s (alist-ref ':scheme h))
	   (h (fold alist-delete h '(:method :path :authority :scheme))))
      (make-request method: m
		    scheme: s
		    authority: a
		    path: p
		    headers: h
		    body: b))))

;;;
;;; response
;;;

(module http-response
    (make-response response-status response-headers response-body make-response-with-headers-and-body response-all-headers)

  (import chicken scheme)
  (use srfi-1 defstruct data-structures)
  
  (defstruct response status (headers '()) body request)

  (define (response-all-headers res)
    (cons `(:status . ,(->string (response-status res)))
	  (response-headers res)))

  (define (make-response-with-headers-and-body headers body)
    (make-response status: (alist-ref ':status headers)
		   headers: (alist-delete ':status headers)
		   body: body)))

;;; 
;;; conn
;;;

(module http-connection
    (make-http-server-connection http-connection-listen http-connection-write-response)

  (import chicken scheme)

  (import http-frame)
  (import http-stream)
  (import http-request)
  (import http-response)
 
  (use srfi-1 data-structures defstruct extras)
  (import hpack)

  (define client-initial-settings
    `((SETTINGS-HEADER-TABLE-SIZE       . 4096)
      (SETTINGS-ENABLE-PUSH             . 1)
      (SETTINGS-MAX-CONCURRENT-STREAMS  . 1024)
      (SETTINGS-INITIAL-WINDOW-SIZE     . 65535)
      (SETTINGS-MAX-FRAME-SIZE          . 16384)
      (SETTINGS-MAX-HEADER-LIST-SIZE    . ,(- (* 16 1024 1024) 1)))) 

  (define server-initial-settings
    `((SETTINGS-HEADER-TABLE-SIZE       . 4096)
      (SETTINGS-MAX-CONCURRENT-STREAMS  . 1024)
      (SETTINGS-INITIAL-WINDOW-SIZE     . 65535)
      (SETTINGS-MAX-FRAME-SIZE          . 16384)
      (SETTINGS-MAX-HEADER-LIST-SIZE    . ,(- (* 16 1024 1024) 1))))

  (defstruct conn mode lsid in out
    local-settings
    peer-settings
    (status 'ready)
    (flow-controller conn-default-flow-controller)
    (decoder (make-header-table)) 
    (encoder (make-header-table)) 
    (active '())
    (ready '())
    (streams '())
    (local-ws 65535)
    (peer-ws 65535))

  (define (conn-default-flow-controller c f)
    (and (eq? (car f) 'data)
	 (let* ((id (cadr f))
		(data (caddr f))
		(wsi (string-length data)))
	   (conn-send c `(window-update 0 ,(string-length (caddr f))))
	   (if (not (zero? id))
	       (let* ((streams (conn-streams c))
		      (stream (alist-ref id streams))
		      (stream (stream-send stream `(window-update ,id ,wsi))))
		 (update-conn c streams: (alist-update id stream streams)))))))
 
  (define (conn-connection-error c ls ec #!optional (dd ""))
    (conn-send c `(goaway ,ls ,ec ,dd)))
 
  ;; conn-send
  (define (conn-send c f)
    (spew "conn-send: " f)
    (let* ((streams (conn-streams c))
	   (local-ws (conn-local-ws c))
	   (t (car f)))
     
      (define (data id data es)
	(set! local-ws (- local-ws (string-length data))))

      (define (headers id hbf eh es esdw)
	(if esdw
	    (apply priority esdw)))
     
      (define (priority id e sd w)
	'())

      (define (rst-stream id ec)
	'())

      (define (settings ls ack)
	'())

      (define (push-promise id psid eh)
	'())

      (define (ping data ack)
	'())

      (define (goaway ls ec dd)
	'())
     
      (define (window-update id wsi)
	(if (zero? id)
	    (set! local-ws (+ local-ws wsi))))

      (define (continuation id hbf eh)
	'())
     
      (if (member t '(data headers rst-stream window-update priority))
	  (let* ((id (cadr f))
		 (stream (alist-ref id streams))
		 (stream (stream-send stream f)))
	    (set! streams (alist-update id stream streams))))
     
      (write-frame f)
      (update-conn c
		   streams: streams
		   local-ws: local-ws)))

  ;; conn-recv
  (define (conn-recv c f handler)
    (spew "conn-recv: " f)
    (let* ((mode (conn-mode c))
	   (status (conn-status c))
	   (in (conn-in c))
	   (out (conn-out c))
	   (lsid (conn-lsid c))
	   (active (conn-active c))
	   (ready (conn-ready c))
	   (peer-settings (conn-peer-settings c))
	   (local-settings (conn-local-settings c))
	   (flow-controller (conn-flow-controller c))
	   (decoder (conn-decoder c))
	   (encoder (conn-encoder c))
	   (streams (conn-streams c))
	   (local-ws (conn-local-ws c))
	   (peer-ws (conn-peer-ws c))
	   (t (car f)))
      (spew "before: " streams)
      (define (connection-error ls ec #!optional (dd ""))
	(conn-connection-error c ls ec dd))
     
      (define (priority id e sd w)
	'())
     
      (define (data id data es)
	(set! local-ws (- (string-length data))))

      (define (headers id hbf eh es esdw)
	(set! streams (if (not (alist-ref id streams))
			  (alist-update id (make-stream) streams)
			  streams))
	(if esdw (apply priority (cons 5 esdw))))

      (define (rst-stream id ec)
	'())

      (define (settings-validate settings ack)
	(let* ((ep (alist-ref 'SETTINGS-ENABLE-PUSH settings))
	       (mfs (alist-ref 'SETTINGS-MAX-FRAME-SIZE settings))
	       (iws (alist-ref 'SETTINGS-INITIAL-WINDOW-SIZE settings)))
	  (if (or (and ack (not (null? settings)))
		  (and ep (eq? 'client mode))
		  (and ep (not (zero? ep)) (not (eq? 1 ep)))
		  (and mfs (< (- (expt 2 24) 1) mfs))
		  (and iws (< (- (expt 2 31) 1) iws)))
	      (connection-error 0 'protocol-error "bad settings frame"))))

      (define (settings-apply settings)
	(set! peer-settings (fold
			     (lambda (setting peer)
			       (let* ((identifier (car setting))
				      (value (cdr setting)))
				 (case identifier
				   ((SETTINGS-HEADER-TABLE-SIZE) (set-header-table! encoder size: value)))
				 (alist-update identifier value peer)))
			     peer-settings
			     settings)))

      (define (settings ls ack)
	(settings-validate ls ack)
	(if (not ack)
	    (begin
	      (settings-apply ls)
	      (conn-send c '(settings () #t)))))

      (define (push-promise-validate id psid)
	(if (or #f ;TODO - if client disabled push, was acknowledged and receives a push - error
		(not (alist-ref id streams))
		(alist-ref psid streams))
	    (connection-error id 'protocol-error "bad push_promise frame")))
     
      (define (push-promise id psid hbf eh)
	(push-promise-validate id psid)
	(set! streams (alist-update id (make-stream) streams)))

      (define (ping data ack)
	(if (not ack)
	    (conn-send c `(ping ,data #t))))

     
      (define (goaway ls ec dd)
	(set! status 'closed))
     
      (define (window-update id wsi)
	(if (zero? id) (set! peer-ws (+ wsi peer-ws))))

      (define (continuation hbf eh)
	'())

      (spew (length f))

      (if (or (and (member t '(data headers priority rst-stream continuation))
		   (zero? (cadr f)))
	      (and (member t '(goaway ping))
		   (not (zero? (cadr f))))
	      (and (eq? 'server mode)
		   (eq? t 'push-promise))
	      (and (eq? 'client mode)
		   (not (zero? (cadr f)))
		   (not (alist-ref (cadr f) streams))))
	  (connection-error (cadr f) 'protocol-error "in conn")
	  (let* ((fn (alist-ref t `((data . ,data)
				    (headers . ,headers)
				    (priority . ,priority)
				    (rst-stream . ,rst-stream)
				    (settings . ,settings)
				    (push-promise . ,push-promise)
				    (ping . ,ping)
				    (goaway . ,goaway)
				    (window-update . ,window-update)
				    (continuation . ,continuation)
				    (connection-error . ,connection-error))))
		 (args (cdr f)))
	    (apply fn args)))
     
      (define (update)
	(update-conn c status: status
		     active: active ready: ready peer-settings: peer-settings local-settings: local-settings
		     decoder: decoder encoder: encoder streams: streams local-ws: local-ws peer-ws: peer-ws))

      ;; process frame within its stream    
      (if (or (member t '(data headers rst-stream continuation push-promise))
	      (and (eq? t 'window-update)
		   (not (zero? (cadr f)))))
	  (let* ((id (cadr f))
		 (stream (alist-ref id streams)))
	    (spew "stream: " id " " stream)
	    (if (stream-accepts? stream t)
		(let* ((shandler (lambda (id hbls db)
				   (let* ((headers (append-map (lambda (hb) (hpack-decode decoder hb)) hbls))
					  (body db)
					  (fn (if (eq? mode 'server)
						  make-request-with-headers-and-body
						  make-response-with-headers-and-body)))
				     (handler (update) id (fn headers body)))))
		       (stream (stream-recv stream f shandler)))
		  (set! streams (alist-update id stream streams)))
		(connection-error id 'protocol-error (conc "not expecting " t " frame")))))
      (spew "after: " streams)
      (update)))

  (define (http-connection-listen conn handler)
    (let lp ((c conn))
      (spew "listen: " (conn-status c) " " (conn-streams c))
      (and (not (eq? 'closed (conn-status c)))
	   (lp (conn-recv c (read-frame) handler)))))

  (define (conn-response->frames conn id res)
    (let* ((encoder (conn-encoder conn)))
      `((headers ,id ,(hpack-encode encoder (response-all-headers res)) #t #f)
	(data ,id ,(response-body res) #t))))

  (define (http-connection-write-response conn id res)
    (let* ((encoder (conn-encoder conn)))
      (fold (lambda (f c)
	      (conn-send c f))
	    conn
	    (conn-response->frames conn id res))))

  (define (conn-read-client-settings conn)
    (let* ((f (read-frame))
	   (t (car f)))
      (if (not (eq? t 'settings))
	  (conn-connection-error conn 0 'protocol-error "expecting settings frame")
	  (conn-recv conn f identity))))
 
  (define (conn-read-client-preface conn)
    (let* ((s (read-string 24)))
      (spew "read client preface: " (string-length s))
      (if (string=? "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n" s)
	  conn
	  (begin
	    (spew s)
	    (spew (read-line))
	    (spew (read-line))
	    (spew (read-line))
	    (spew (read-line))
	    (spew (read-line))
	    (spew (read-line))
	    (spew (read-line))
	    (spew (read-line))
	    (spew (read-line))
	    (conn-connection-error conn 0 'protocol-error "bad client preface"))))
    conn)
  
 
  (define (conn-write-server-preface conn)
    (write-frame `(settings ,(conn-local-settings conn) #f))
    conn)
 
  (define (make-http-server-connection
	   #!optional
	   (in (current-input-port))
	   (out (current-output-port)))
    (conn-read-client-settings
     (conn-read-client-preface
      (conn-write-server-preface
       (make-conn mode: 'server
		  in: in
		  out: out
		  local-settings: server-initial-settings
		  peer-settings: client-initial-settings))))))

;;server
(use tcp-server)

(import http-response)
(import http-request)
(import http-connection)

(use openssl)

(define (make-http-server-handler handler)
  ;; todo - run each request handler as a seperate thread (use mutexes on write-response)
  (lambda (conn id req)
	     (http-connection-write-response
	      conn
	      id
	      (handler req))))

(define (make-http-server handler)
  (lambda (ignore)
    (let* ((l (ssl-listen* hostname: "127.0.0.1"
			   port: 8000
			   protocol: 'tlsv12
			   certificate: "server.pem"
			   private-key: "server.key"
			   private-key-type: 'ec)))
      (let lp ()
	(receive (in out)
	    (ssl-accept l)
	  (thread-start!
	   (make-thread
	    (lambda ()
	      (current-input-port in)
	      (current-output-port out)
	      (http-connection-listen (make-http-server-connection)
				      (make-http-server-handler handler))))))
	
	(lp)))))



;; driver
(define (handler req)
  (make-response status: 200
		 body: (with-output-to-string
			 (lambda ()
			   (display (request-pseudo-headers req))))))

((make-http-server handler) #t)
